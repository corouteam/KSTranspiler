Index: src/test/kotlin/ValidationTest.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package it.poliba.KSTranspiler\n\nimport it.poliba.KSTranspiler.facade.KotlinParserFacade\nimport it.poliba.KSTranspiler.facade.SwiftParserFacade\nimport org.junit.jupiter.api.Test\nimport kotlin.test.assertEquals\n\nclass ValidationTest {\n\n    @Test\n    fun `array matches type`() {\n        var code = \"val list = listOf<Int>(1, 2, \\\"a\\\")\"\n        val parseResult = KotlinParserFacade.parse(code)\n\n        assert(parseResult.errors.isNotEmpty())\n        assertEquals(parseResult.errors.first().message, \"\"\"\n            List can't contain different types.\n            Found String in a list of Int\n        \"\"\".trimIndent())\n    }\n\n    @Test\n    fun `variable not duplicate in function`() {\n        var code = \"\"\"\n            val a = 1\n            \n            fun test() {\n                val b = 2\n                val b = 3\n            }\n        \"\"\".trimIndent()\n        val parseResult = KotlinParserFacade.parse(code)\n\n        assert(parseResult.errors.isNotEmpty())\n        assertEquals(parseResult.errors.first().message,\"A variable named 'b' has been already declared\")\n    }\n\n    @Test\n    fun `variable in different scope can have same name`() {\n        var code = \"\"\"\n            val a = 1\n            \n            fun test() {\n                val a = 3\n                val b = 2\n            }\n        \"\"\".trimIndent()\n        val parseResult = KotlinParserFacade.parse(code)\n\n        assert(parseResult.errors.isEmpty())\n    }\n\n    @Test\n    fun `global variable not duplicate`() {\n        var code = \"\"\"\n            val a = 1\n            val a = 2\n        \"\"\".trimIndent()\n        val parseResult = KotlinParserFacade.parse(code)\n\n        assert(parseResult.errors.isNotEmpty())\n        assertEquals(\"A variable named 'a' has been already declared\", parseResult.errors.first().message)\n    }\n\n    @Test\n    fun `variable not declared throws error`() {\n        var code = \"\"\"\n            fun test() {\n                print(a)\n            }\n        \"\"\".trimIndent()\n        val parseResult = KotlinParserFacade.parse(code)\n\n        assert(parseResult.errors.isNotEmpty())\n        assertEquals(\"A variable named 'a' is used but never declared\", parseResult.errors.first().message)\n    }\n\n    @Test\n    fun `variable not declared in script throws error`() {\n        var code = \"\"\"\n            print(a)\n        \"\"\".trimIndent()\n        val parseResult = KotlinParserFacadeScript.parse(code)\n\n        assert(parseResult.errors.isNotEmpty())\n        assertEquals(\"A variable named 'a' is used but never declared\", parseResult.errors.first().message)\n    }\n\n    @Test\n    fun `variable declared in different scope does not throw error`() {\n        var code = \"\"\"\n            val a = \"Hello world!\"\n            \n            fun test() {\n                print(a)\n            }\n        \"\"\".trimIndent()\n        val parseResult = KotlinParserFacade.parse(code)\n\n        assert(parseResult.errors.isEmpty())\n    }\n\n    @Test\n    fun `var type mismatch is reported`() {\n        var code = \"\"\"\n            val a: Int = \"a\"\n        \"\"\".trimIndent()\n        val parseResult = KotlinParserFacade.parse(code)\n\n        assert(parseResult.errors.isNotEmpty())\n        assertEquals(\"\"\"\n            Type mismatch (String assigned to a variable of type Int).\n        \"\"\".trimIndent(), parseResult.errors.first().message)\n    }\n\n    @Test\n    fun `if condition must be boolean`() {\n        var code = \"\"\"\n            fun main(){\n                if (42) {\n                    print(\"hello\")\n                }\n            }\n        \"\"\".trimIndent()\n        val parseResult = KotlinParserFacade.parse(code)\n\n        assert(parseResult.errors.isNotEmpty())\n        assertEquals(\"If condition must be a boolean expression.\", parseResult.errors.first().message)\n    }\n\n    @Test\n    fun `global val can not be reassigned`() {\n        var code = \"\"\"\n            val a = 1\n            \n            fun main(){\n                a = 2\n            }\n        \"\"\".trimIndent()\n        val parseResult = KotlinParserFacade.parse(code)\n\n        assert(parseResult.errors.isNotEmpty())\n        assertEquals(\"\"\"\n            Final variable a can not be reassigned.\n        \"\"\".trimIndent(), parseResult.errors.first().message)\n    }\n\n    @Test\n    fun `val can not be reassigned`() {\n        var code = \"\"\"\n            \n            fun main(){\n                val a = 1\n                a = 2\n            }\n        \"\"\".trimIndent()\n        val parseResult = KotlinParserFacade.parse(code)\n\n        assert(parseResult.errors.isNotEmpty())\n        assertEquals(\"\"\"\n            Final variable a can not be reassigned.\n        \"\"\".trimIndent(), parseResult.errors.first().message)\n    }\n\n    @Test\n    fun `global var type mismatch between different declaration and assignment is reported`() {\n        var code = \"\"\"\n            var a = 1\n            \n            fun main() {\n                a = \"hello\"\n            }\n        \"\"\".trimIndent()\n        val parseResult = KotlinParserFacade.parse(code)\n\n        assert(parseResult.errors.isNotEmpty())\n        assertEquals(\"\"\"\n            Type mismatch (String assigned to a variable of type Int).\n        \"\"\".trimIndent(), parseResult.errors.first().message)\n    }\n\n    @Test\n    fun `var type mismatch between different declaration and assignment is reported`() {\n        var code = \"\"\"            \n            fun main() {\n                var a = 1\n                a = \"hello\"\n            }\n        \"\"\".trimIndent()\n        val parseResult = KotlinParserFacade.parse(code)\n\n        assert(parseResult.errors.isNotEmpty())\n        assertEquals(\"\"\"\n            Type mismatch (String assigned to a variable of type Int).\n        \"\"\".trimIndent(), parseResult.errors.first().message)\n    }\n\n    @Test\n    fun `function return required is reported`() {\n        var code = \"\"\"\n            fun testReturn(): String {\n                print(\"hello\")\n            }\n        \"\"\".trimIndent()\n        val parseResult = KotlinParserFacade.parse(code)\n\n        assert(parseResult.errors.isNotEmpty())\n        assertEquals(\"\"\"\n            A return expression is required for the function testReturn.\n        \"\"\".trimIndent(), parseResult.errors.first().message)\n    }\n\n    @Test\n    fun `function return with different type is reported`() {\n        var code = \"\"\"\n            fun testReturnType(): String {\n                print(\"hello\")\n                return true\n            }\n        \"\"\".trimIndent()\n        val parseResult = KotlinParserFacade.parse(code)\n\n        assert(parseResult.errors.isNotEmpty())\n        assertEquals(\"\"\"\n            The return type Boolean does not\n            conform to the expected type String\n            of the function testReturnType.\n        \"\"\".trimIndent(), parseResult.errors.first().message)\n    }\n\n    @Test\n    fun `function return reference with different type is reported`() {\n        var code = \"\"\"\n            val a: Boolean = true\n\n            fun testReturnType(): String {\n\n                print(\"hello\")\n                return a\n            }\n        \"\"\".trimIndent()\n        val parseResult = KotlinParserFacade.parse(code)\n\n        assert(parseResult.errors.isNotEmpty())\n        assertEquals(\"\"\"\n            The return type Boolean does not\n            conform to the expected type String\n            of the function testReturnType.\n        \"\"\".trimIndent(), parseResult.errors.first().message)\n    }\n\n    @Test\n    fun `composable function always return a composable`() {\n        var code = \"\"\"\n            @Composable\n            fun testComposable(){\n                print(\"hello without composable\")\n            }\n        \"\"\".trimIndent()\n        val parseResult = KotlinParserFacade.parse(code)\n\n        assert(parseResult.errors.isNotEmpty())\n        assertEquals(\"\"\"\n            Function testComposable is expected to declare a Composable\n        \"\"\".trimIndent(), parseResult.errors.first().message)\n    }\n\n    @Test\n    fun `SwiftUi funciton always returns a widget`(){\n        var code = \"\"\"\n            struct test: View{\n                var x: Int\n                var y: Int\n            }\n        \"\"\".trimIndent()\n        val parseResult = SwiftParserFacade.parse(code)\n\n        assert(parseResult.errors.isNotEmpty())\n        assertEquals(\"\"\"\n            Struct declaration is required to return a widget\n        \"\"\".trimIndent(), parseResult.errors.first().message)\n    }\n\n    @Test\n    fun `data class must have only property parameters`(){\n        val code = \"\"\"\n        data class Person(\n        firstName: String,\n        val lastName: String\n        ): Address, Jks {\n            init {\n                print(\"Hello\")\n            }\n        }\"\"\".trimMargin()\n\n        val parseResult = KotlinParserFacade.parse(code)\n\n        assert(parseResult.errors.isNotEmpty())\n        assertEquals(\"\"\"\n            Data class must have only property parameters\n        \"\"\".trimIndent(), parseResult.errors.first().message)\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/kotlin/ValidationTest.kt b/src/test/kotlin/ValidationTest.kt
--- a/src/test/kotlin/ValidationTest.kt	(revision 87b59e46f3db137d3548730b8fb4836cdd17cd2a)
+++ b/src/test/kotlin/ValidationTest.kt	(date 1682270085123)
@@ -80,7 +80,7 @@
         var code = """
             print(a)
         """.trimIndent()
-        val parseResult = KotlinParserFacadeScript.parse(code)
+        val parseResult = KotlinParserFacade.parse(code)
 
         assert(parseResult.errors.isNotEmpty())
         assertEquals("A variable named 'a' is used but never declared", parseResult.errors.first().message)
